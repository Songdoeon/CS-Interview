# 데이터베이스
해당 답변은 mysql을 기준으로 답변합니다.   

저의 생각과 서칭기반으로 작성한 내용이라 틀린점이 있을 수 있습니다.  
혹시 틀렸다고 생각이 든다면 의견 남겨주세요.
<details>
  <summary><h3>1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.</h3></summary>
  
- 기본키는 수정이 가능한가요?
  - Alter를 이용해 기본키를 삭제하고 다시 생성한다.
    - 생성 : `Alter table 테이블명 add (constraint 제약조건이름) primary key(컬럼명, 컬럼명)`
    - 삭제 : `Alter table 테이블명 drop (constraint 제약조건이름) primary key`
  - 기본키가 auto_increment일 경우 auto_increment를 해제후 삭제한다.
- 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
  - 먼저 답으로는 기본적으로 사용자가 설정하지 않아도 auto_increment 속성의 Generated Invisibed PK가 생성됩니다.
  - 그렇기에 그냥 명시적으로 생성하고 해당 컬럼을 활용하는것이 좋습니다.
  - PK가 없는 테이블에서 대량의 변경작업이 발생한다면, secondary장비에서 복제 지연이 발생하는 경우를 간헐적으로 경험할 수 있다고합니다.
    - [리플리케이션 문제(feat.복제지연, semi-sync)](https://iiaii.tistory.com/entry/%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95-%EB%B3%B5%EC%A0%9C%EC%A7%80%EC%97%B0-semi-sync)
  - 기본키가 있는 경우 테이블 탐색에 용이합니다.
  - 기본키를 이용하여 중복데이터 제거 나 검색시 특정 인덱스만 찾아보는 등의 방식이 가능하기 때문입니다.
  - 하지만 기본키가 없다고 테이블이 아닌것은 아니나 관계형 데이터베이스가 지향하는점과 어긋나는 경향이 있습니다.
  - [기본키에 대한 탐구](https://blog.naver.com/PostView.naver?blogId=k65fac&logNo=222399911833&parentCategoryNo=&categoryNo=68&viewDate=&isShowPopularPosts=true&from=search)
  - [리플리케이션](https://iiaii.tistory.com/entry/%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98Replication)

- 외래키 값은 NULL이 들어올 수 있나요?
  - 네 가능합니다.
  - 하지만 대부분의 외래키는 다른 테이블의 PK 또는 UK입니다.
  - 그렇기에 특별한 경우가 아니라면 참조 무결성을 지켜주는것이 좋습니다.
  - 하지만 모든사원은 부서를 가지고 있지만 신입사원은 부서가 정해지지 않았을 수도 있으니 NULL일 수도 있겠죠?

- 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
  - 해당 문제가 pk같은 인덱스 활용을 묻는것인지 pk가 아닌 unique 칼럼을 묻는것인지 모르겠다.
    - 일단 대충 정리하도록 하겠음
  - row-based 환경에서 pk가 없는 테이블의 replication할때 활용 가능하다.
  - UNIQUE 칼럼은 secondary index로 활용이 가능합니다.
  - 테이블당 여러개를 가질 수 있다.
  - 테이블은 clustered index를 기준으로 정렬되어있기에 secondary index 기준으로는 정렬되어 있지않다.
  - 하지만 secondary index가 꼭 unique 칼럼을 이용하는것은 아니다.
</details>

<details>
  <summary><h3>2. RDB와 NoSQL의 차이에 대해 설명해 주세요.</h3></summary>
  
- RDB의 강점과, 약점이 무엇인가요?
  - 강점
    - ACID, Transaction을 지원한다.
    - 명확한 데이터 구조 보장
    - UPDATE가 잦은 시스템에 용이
  - 약점
    - ACID, Transaction을 지키며 수평적 확장하는 것이 쉽지않다.(join 연산의 복잡성, 샤딩의 어려움)
    - 스키마 변경의 어려움
    - 복잡한 쿼리 연산에서의 성능 저하 우려
    - 비정형 데이터 처리의 한계
      
- NoSQL의 강점과, 약점이 무엇인가요?
  - 강점
    - 유연하고 자유로운 데이터 구조
    - 새로운 필드 추가의 자유로움
    - 많은 데이터양 처리에 용이
    - 수평적 확장 용이
  - 약점
    - ACID, Transaction을 지원하지 않는다.
    - 데이터 중복 발생 가능
    - 많은 중복 데이터로 인해 데이터 변경시 모든 컬렉션에서 수정해야함
    - 데이터 일관성 저하 및 용량 증가
    - 명확한 데이터 구조 보장 X

- RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)
  - RDB의 경우 데이터의 무결성이 특징이라고 생각합니다.
  - 그렇기에 데이터의 여러 무결성들을 지키려면 Transaction과 lock 같은 기능이 잘 활용 되어야 하는데
  - 그러한 기능들이 같은양의 트래픽일 때 NoSQL보다 부하가 더 걸릴 요소로 작용한다고 생각합니다.
  - 많은 트래픽이 요구되는 상황에서 RDB의 경우 분산 DB설계가 쉽지 않습니다.
    - master/slave 구조 에서의 데이터 동기화 문제
    - 데이터 샤딩시 HotSpot-key 문제
    - 안정 해시 전략 구조
- NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.
  - ~~활용한 경험 없음 ㅇㅁㅇ~~
  - 비 관계형 데이터베이스가 바람직한 경우
    - 아주 낮은 응답 지연시간이 요구됨
    - 다루는 데이터가 비정형데이터
    - 데이터를 직렬화 하거나 역직렬화 할 수 있기만 하면됨
    - 아주 많은 양의 데이터를 저장해야함
      
</details>

<details>
  <summary><h3>3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.</h3></summary>
트랜잭션이란 DB를 탐색,변경을 수행하는 작업 단위입니다.

DB는 트랜잭션을 관리하여 무결성의 원칙을 관리합니다. <- 애매한 발언

- ACID 원칙을 DBMS는 어떻게 보장하나요?
  - 원자성(Atomicity)
    - 현재 수행하고 있는 트랜잭션의 변경 내역을 유지하며, 이전 commit된 상태를 임시 영역에 저장한다.
    - 수행중 트랜잭션 오류 발생시 임시 영역에 저장한 상태로 rollback한다.
    - UNDO 로그를 활용하여 rollback을 진행한다.
  - 일관성(Consistency)
    - 일관성은 트랜잭션 수행 전,후 데이터 모델의 모든 제약 조건을 만족하는것을 통해 보장한다.
    - 테이블의 일관성을 깨는 데이터를 받아선 안된다는 느낌입니다.
    - 지속성과 차이점을 명확하게 알면 좋을것 같습니다.
    - 테이블 간의 참조키를 변경시 두 테이블 모두 데이터를 변경함으로써 일관성을 보장합니다.
  - 고립성(Isolation)
    - 병행 처리(concurrent processing)
      1. CPU의 멀티프로세싱과 마찬가지로 트랜잭션에 정해진 시간을 할당하는 방식으로 진행합니다.
      2. 시간이 끝나면 다른 트랜잭션을 실행하는 방식으로 트랜잭션들을 조금씩 처리합니다.
      3. 트랜잭션의 간섭이 일어날 경우 Dirty Read, Non-repeatable Read, Phantom Read등 여러 문제가 발생합니다.
    - 고립성 보장
      1. 병행 처리를 위해선 고립성 보장이 중요합니다.
      2. 세마포어와 비슷한 개념으로 lock % excute unlock을 통해 고립성을 보장합니다.
      3. 하지만 lock, unlock의 부작용으로 데드락상태에 빠질 수 있습니다.
    - 2PL 프로토콜(2 Phase Locking)
      1. 데드락 방지를 위한 프로토콜입니다.
      2. 2가지의 locking 단계가 존재합니다.
      3. 상승 단계(grwoing pahse)는 read_lock, write_lock을 의미합니다.
      4. 하강 단계(shrinking phase)는 unlock을 의미합니다.
      5. 두 단계가 번갈아 수행되지 않고 lock이 다 수행된후 unlock을 수행해야한다는 프로토콜입니다.
    - 참고로 locking에도 두 가지의 방법이 있습니다.
    - 보수적 locking(conservative locking)
      1. 트랜잭션이 시작되면 모든 lock을 얻는 방식
      2. 데드락이 발생하지 않지만 병행성이 좋지 못함
    - 엄격한 locking(strict locking)
      1. 트랜잭션이 commit을 만날 때까지 lock을 가지고 commit을 만나면 unlock하는 방식
      2. 데드락이 발생하지만 병행성이 좋음
      3. 일반적으로 병행성이 좋은 strict 방식을 사용합니다.
  - 지속성(Durability)
    - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구 저장해야한다.
    - Durability는 내구성이라는 뜻도 가지고 있습니다.
    - 성공적으로 수행된 트랜잭션의 경우 장애가 발생하여도 데이터 자체에는 영향없이 보존되어야 한다는 뜻입니다.
    - DB 장애 발생시 회복절차를 수행하여 발생 이전의 DB로 만든다.
    - 일정 주기로 원본 내용을 덤프에 저장해두거나, 로그파일을 이용해 이전 상태로 되돌립니다.
    - 트랜잭션 종료 후 발생한 장애에는 종료를 확정하기 위해 REDO로그를 이용합니다.
    - 트랜잭션중 발생한 장애는 트랜잭션을 취소하기 위해 UNDO 로그를 이용합니다.
- 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
  - 답변이 어렵당.
- 읽기에는 트랜잭션을 걸지 않아도 될까요?
  - 트랜잭션 진행중 발생한 장애에 대비한 로그가 남지 않아도 됩니다.
  - JPA의 경우에는 더티체크를 위한 스냅샷을 저장하지 않아도 됩니다. (다른 ORM 몰라)
  - Transaction ID 설정에 대한 오버헤드를 해결해줍니다.
  - 그리고 Master/slave 환경에서 분산에도 용이할것입니다.
</details>

<details>
  <summary><h3>4. 트랜잭션 격리 레벨에 대해 설명해 주세요.</h3></summary>

- 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
  - PostgreSQL은 READ UNCOMMITED를 지원하지 않습니다.
  - ANSI 문법 호환성 때문에 문법을 허용하지만 내부적으로는 readcommiteed 격리수준으로 작동합니다.
  - 표준 규약에서는 각 수준에서 발생하면 안되는 경우는 언급하지만 그보다 엄격한 방식은 허용한다.
  - PostgreSQL은 다중 버전 동시성 제어를 구현하는 경우 Read Uncommitted 수준을 지원할 수 없기에 지원하지 않는다고 합니다.
  - mySQL은 4가지를 다 구성하고 있습니다.
  - 하지만 Mysql의 InnoDB의 경우 갭 락과 넥스트 키 락으로 인해 이미 REPEATABLE READ수준 에서도 PHANTOM READ가 발생하지 않는다.
    
- 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
  - 영역을 로그와 같은 말이라고 생각하고 답변 하겠습니다.
  - undo 로그는 변경 내역이 저장되고 Redo로그는 변경 이후의 내역이 저장됩니다.
  - 트랜잭션 종료 후 발생한 장애에는 종료를 확정하기 위해 REDO로그를 이용합니다.
  - 트랜잭션중 발생한 장애는 트랜잭션을 취소하기 위해 UNDO 로그를 이용합니다.
- 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?
  - 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 전담합니다.
  - 스토리지 엔진은 데이터 테이블을 어떤 방식으로 구성할것인지 세팅이 되어있습니다.
  - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리함(지연 쓰기가 있지만 일반적인 방식은 아님)
  - InnoDB 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 나머지 버퍼로 부터 디스크까지 기록하는 작업은 백스레드가 처리한다.
  - 여러가지 차이가 있다.
</details>

<details>
  <summary><h3>5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.</h3></summary>
  
현재 index 부분을 읽기 전이라 읽고 난 후 좀더 깊이있게 정리해보겠습니다.

- 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
  - 인덱스는 CUD 방식보단 Read 방식을 활용할때 그 장점이 발휘합니다.
  - 탐색에는 용이하지만, 데이터의 수정이나 삽입이 발생하면 그것에 맞추어 index 또한 변경이 일어나야 합니다.
  - 그렇기에 수정이 잦은 테이블에선 index의 효율이 떨어집니다.
  
- 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
  - 위 정책을 따라가냐는게 무슨말인지 모르겠음
    
- ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.

- 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?

- 그렇다면 외래키는요?

- 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?

- 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?

- (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
- 
</details>

<details>
  <summary><h3>6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.</h3></summary>
  
~~Nosql 생략 빠밤~~
  
- 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?
  - slave 환경에서는 데이터의 읽기만 수정과 삽입은 master 노드에서만 진행하도록 트랜잭션을 관리 할 수 있겠습니다.
    
- 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
  - 복제 방식에는 비동기 복제, 반동기 복제 방식이 존재합니다.
  - 비동기 복제는 트랜잭션의 commit이 복제 DB에 바로 반영되지는 않습니다.
  - 반동기 복제는 master에서 slave의 ACK를 받고 Transaction을 진행한다.
  - 정합성을 보장해주지만 오히려 원래의 의도를 벗어나 slave가 master에 영향을 미친다.
  - 본인 서비스에 맞도록 잘 정해서 서비스 하는게 좋을 것같습니다.
- 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
  - 2PL 프로토콜(2 Phase Locking)
    - 데드락 방지를 위한 프로토콜입니다.
    - 2가지의 locking 단계가 존재합니다.
    - 상승 단계(grwoing pahse)는 read_lock, write_lock을 의미합니다.
    - 하강 단계(shrinking phase)는 unlock을 의미합니다.
    - 두 단계가 번갈아 수행되지 않고 lock이 다 수행된후 unlock을 수행해야한다는 프로토콜입니다.
- 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?
  - DB 샤딩은 여러 DB에 같은 데이터를 가지고 있는것이 아닌 각기 다 다른 데이터를 가지도록 DB를 분산하는 방식입니다.
  - 두 방식의 장점과 단점이 다르다고 생각합니다. 그렇기에 상황에 맞게 활용하는게 중요하다고 생각합니다.
  - 샤딩 방식
    - 동일한 스키마의 DB를 유지하기에 수평적 확장에 용이할것입니다.
    - 하지만 프로그램 복잡도 상승 및 서버간 연결 비용 증가
  - 레플리케이션
    - DB는 대부분의 경우 read 작업이 많기에 replication만으로도 충분히 성능을 높힐 수 있음.
    - 비동기 동기화로 진행시 지연시간이 거의 없다. (?)
    - 장애 대응에 용이하다.
    - 하지만 각각 다른 서버에서 운영하기에 동기화 과정에서 정합성이 깨질 수 있다.
</details>

<details>
  <summary><h3>7. 정규화가 무엇인가요?</h3></summary>
  
정규화(Normalization)의 기본 목표는 테이블 간에 중복된 데이타를 허용하지 않는다는 것입니다.
  
중복된 데이터를 허용하지 않음으로써 무결성(Integrity)를 유지할 수 있으며,   
DB의 저장 용량 역시 줄일 수 있습니다.
  
- 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
  - 삭제 이상(deletion anomly)
    - 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
  - 삽입 이상(insertion anomly)
    - 튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL값을 입력해야 하는 현상
  - 수정 이상(update anomly)
    - 튜플 수정 시 중복된 데이터의 일부만 수정되어 데이터의 불일치 문제가 일어나는 현상
  - 정규화를 진행하면 이상 현상들을 제거할 수 있습니다.
  - 하지만 릴레이션이 너무 많아지면 join 연산의 부담이 증가하게 됩니다.
- 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.
  - 제 1 정규형(1NF)
    - 모든 칼럼은 하나의 값을 가지도록 합니다.
  - 제 2 정규형(2NF)
    - 제 1정규형을 지킨 상태에서 
- 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.

</details>
